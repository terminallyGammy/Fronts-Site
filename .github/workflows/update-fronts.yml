name: Update Fronts (SimplyPlural → fronts.json)

on:
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch: {}

permissions:
  contents: write

env:
  PAGES_BRANCH: main
  PAGES_DIR: .

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Pages branch
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PAGES_BRANCH }}
          fetch-depth: 0

      - name: "Debug: show branch & tree"
        shell: bash
        run: |
          echo "On branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Repo root contents:"; ls -la
          echo "PAGES_DIR contents:"; ls -la "${{ env.PAGES_DIR }}" || true

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch fronters + members + custom fields → fronts.json
        shell: bash
        env:
          PAGES_DIR: ${{ env.PAGES_DIR }}
          SP_TOKEN: ${{ secrets.SP_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p "${PAGES_DIR}"

          # -------- 1) systemId --------
          echo "→ /v1/me"
          CODE_ME=$(curl -sS -o "${PAGES_DIR}/me.json" -w "%{http_code}" \
            -H "Authorization: ${SP_TOKEN}" -H "Accept: application/json" \
            https://api.apparyllis.com/v1/me || true)
          echo "HTTP ${CODE_ME}"
          [ "${CODE_ME}" = "200" ] || { echo "Cannot fetch /v1/me"; head -c 400 "${PAGES_DIR}/me.json" || true; exit 1; }
          SYSTEM_ID=$(jq -r '.content.systemId // .content.uid // .id' "${PAGES_DIR}/me.json")
          [ -n "${SYSTEM_ID}" ] || { echo "systemId not found"; exit 1; }
          echo "systemId=${SYSTEM_ID}"

          # -------- 2) fronters (history) --------
          echo "→ /v1/fronters/"
          CODE_F=$(curl -sS -o "${PAGES_DIR}/fh.json" -w "%{http_code}" \
            -H "Authorization: ${SP_TOKEN}" -H "Accept: application/json" \
            https://api.apparyllis.com/v1/fronters/ || true)
          echo "HTTP ${CODE_F}"
          [ "${CODE_F}" = "200" ] || { echo "Cannot get fronters"; head -c 400 "${PAGES_DIR}/fh.json" || true; exit 1; }

          echo "First 400 chars of fh.json (debug):"
          head -c 400 "${PAGES_DIR}/fh.json" || true; echo

          # Compute lastChange (ms → ISO later)
          LAST_CHANGE=$(jq -r '
            [ .[] | .content.lastOperationTime?, .content.startTime? ]
            | map(select(.!=null)) | max // empty
          ' "${PAGES_DIR}/fh.json")
          : "${LAST_CHANGE:=}"

          # Derive current live fronters robustly:
          # 1) Sort before group_by (jq requires pre-sorted input)
          # 2) Latest-event-per-member AND direct live==true union (covers both shapes)
          LIVE_IDS=$(jq -r '
            def ts: (.content.lastOperationTime // .content.startTime // 0);
            ( . as $a
              | ( $a
                  | sort_by(.content.member, ts)
                  | group_by(.content.member)
                  | map( max_by(ts) )
                  | map(select(.content.live == true))
                  | map(.content.member)
                ) as $latest
              | ( $a
                  | map(select(.content.live == true))
                  | map(.content.member)
                ) as $direct
              | ( ($latest + $direct) | unique | .[]? )
            )
          ' "${PAGES_DIR}/fh.json" || true)

          # Build a proper JSON array from LIVE_IDS for reuse in jq (works even if empty)
          IDS_JSON=$(printf '%s\n' ${LIVE_IDS:-} | jq -R . | jq -s .)
          echo "Resolved live IDs JSON: ${IDS_JSON}"

          # -------- 3) members (full) --------
          echo "→ /v1/members/${SYSTEM_ID}"
          CODE_MEM=$(curl -sS -o "${PAGES_DIR}/members.json" -w "%{http_code}" \
            -H "Authorization: ${SP_TOKEN}" -H "Accept: application/json" \
            "https://api.apparyllis.com/v1/members/${SYSTEM_ID}" || true)
          echo "HTTP ${CODE_MEM}"
          [ "${CODE_MEM}" = "200" ] || { echo "Cannot get members"; head -c 400 "${PAGES_DIR}/members.json" || true; exit 1; }

          echo "First 400 chars of members.json (debug):"
          head -c 400 "${PAGES_DIR}/members.json" || true; echo

          # -------- 3b) Ensure the live IDs are present; fetch missing ones per-member --------
          # Compute which live IDs are not present in the bulk members list
          MISSING_IDS=$(jq -r \
            --argjson mem "$(cat "${PAGES_DIR}/members.json")" \
            --argjson ids "${IDS_JSON:-[]}" '
            [ $mem[]?.id ] as $have
            | [ $ids[] | select( ($have | index(.) ) | not ) ]
            | .[]
          ')
          echo "Missing member IDs (will fetch individually):"
          printf '%s\n' ${MISSING_IDS:-} || true
          
          # Build an array file to hold individually-fetched members (same outer shape as bulk list)
          echo '[]' > "${PAGES_DIR}/members_extra.json"
          for ID in ${MISSING_IDS:-}; do
            URL_MEM="https://api.apparyllis.com/v1/member/${SYSTEM_ID}/${ID}"
            echo "→ ${URL_MEM}"
            CODE_ONE=$(curl -sS -o "${PAGES_DIR}/m_one.json" -w "%{http_code}" \
              -H "Authorization: ${SP_TOKEN}" -H "Accept: application/json" "${URL_MEM}" || true)
            if [ "${CODE_ONE}" = "200" ]; then
              # Normalize to the same list-item shape: {"exists":true,"id":ID,"content":{...}}
              jq -S --arg id "${ID}" '{ exists: true, id: $id, content: . }' "${PAGES_DIR}/m_one.json" > "${PAGES_DIR}/m_one.norm.json"
              jq -S '. + [ input ]' "${PAGES_DIR}/members_extra.json" "${PAGES_DIR}/m_one.norm.json" > "${PAGES_DIR}/members_extra.new.json"
              mv "${PAGES_DIR}/members_extra.new.json" "${PAGES_DIR}/members_extra.json"
            else
              echo "WARN: per-member fetch ${ID} failed (${CODE_ONE}); skipping."
            fi
          done
          
          echo "First 400 chars of members_extra.json (debug):"
          head -c 400 "${PAGES_DIR}/members_extra.json" || true; echo

          # -------- 4) Discover field IDs from the *live members* --------
          # We look at (a) object keys AND (b) .name inside each object entry, because your tenant stores the fieldId in .name.
          jq -r \
            --argjson mem "$(cat "${PAGES_DIR}/members.json")" \
            --argjson mem_extra "$(cat "${PAGES_DIR}/members_extra.json")" \
            --argjson ids_json "${IDS_JSON:-[]}" '
            ($ids_json) as $ids
            | [ ($mem + $mem_extra)[] | select($ids | index(.id)) | .content ] as $LM
            | [
                # object maps: keys + nested .name
                ($LM[] | (.fields       // {} | to_entries[]? | .key)),
                ($LM[] | (.fieldValues  // {} | to_entries[]? | .key)),
                ($LM[] | (.fieldsValue  // {} | to_entries[]? | .key)),
                ($LM[] | (.values       // {} | to_entries[]? | .key)),
                ($LM[] | (.fields       // {} | to_entries[]? | .value.name?)),
                ($LM[] | (.fieldValues  // {} | to_entries[]? | .value.name?)),
                ($LM[] | (.fieldsValue  // {} | to_entries[]? | .value.name?)),
                ($LM[] | (.values       // {} | to_entries[]? | .value.name?)),
                # array shapes: .id or .name
                ($LM[] | (.fields       // [] | .[]? | (.id // .name))),
                ($LM[] | (.infoFields   // [] | .[]? | (.id // .name)))
              ]
            | flatten
            | map(select(. != null and . != ""))
            | unique
            | .[]
          ' > "${PAGES_DIR}/field_ids.txt" || true

          echo "Field IDs discovered (first 30):"
          head -n 30 "${PAGES_DIR}/field_ids.txt" || true

          # -------- 5) Resolve labels for each fieldId (best-effort) --------
          echo '[]' > "${PAGES_DIR}/fielddefs.json"
          while IFS= read -r FID; do
            [ -n "${FID}" ] || continue
            URL1="https://api.apparyllis.com/v1/field/${SYSTEM_ID}/${FID}"
            URL2="https://api.apparyllis.com/v1/field/${FID}"
            CODE=$(curl -sS -o "${PAGES_DIR}/onefield.json" -w "%{http_code}" \
              -H "Authorization: ${SP_TOKEN}" -H "Accept: application/json" "${URL1}" || true)
            if [ "${CODE}" != "200" ]; then
              CODE=$(curl -sS -o "${PAGES_DIR}/onefield.json" -w "%{http_code}" \
                -H "Authorization: ${SP_TOKEN}" -H "Accept: application/json" "${URL2}" || true)
            fi
            if [ "${CODE}" = "200" ]; then
              jq -S --arg id "${FID}" '
                { id: $id, name: (.name // .label // .title // .id // $id) }
              ' "${PAGES_DIR}/onefield.json" > "${PAGES_DIR}/onefield.norm.json"
              jq -S '. + [ input ]' "${PAGES_DIR}/fielddefs.json" "${PAGES_DIR}/onefield.norm.json" > "${PAGES_DIR}/fielddefs.new.json"
              mv "${PAGES_DIR}/fielddefs.new.json" "${PAGES_DIR}/fielddefs.json"
            fi
          done < "${PAGES_DIR}/field_ids.txt"

          # -------- 6) Join to fronts.json (pulling values from many shapes) --------
          jq -n \
            --argjson fh  "$(cat "${PAGES_DIR}/fh.json")" \
            --argjson mem "$(cat "${PAGES_DIR}/members.json")" \
            --argjson mem_extra "$(cat "${PAGES_DIR}/members_extra.json")" \
            --argjson fdef "$(cat "${PAGES_DIR}/fielddefs.json" 2>/dev/null || echo '[]')" \
            --arg lc "${LAST_CHANGE:-}" \
            --argjson ids_json "${IDS_JSON:-[]}" '
          # Build id->label map (fallback to id when unknown)
          def to_label_map:
            (reduce .[] as $d ({}; . + { ($d.id // ""): ($d.name // "") }))
            | with_entries(select(.key != "" and .value != ""));

          # Fetch a value for a given fieldId by searching all the known containers
          def value_for($m; $fid):
            # exact id in known maps
            ($m.fieldValues[$fid] // $m.fields[$fid] // $m.fieldsValue[$fid] // $m.values[$fid]) as $hit
            | if $hit != null then
                if ($hit|type)=="object" then ($hit.value // $hit.text // $hit.content // $hit.markdown // $hit.val // ($hit|tostring))
                else $hit
                end
              else
                # look for entries where .name == fid inside object maps
                (
                  ($m.fields       // {} | to_entries[]? | select(.value.name? == $fid) | .value.value?),
                  ($m.fieldValues  // {} | to_entries[]? | select(.value.name? == $fid) | .value.value?),
                  ($m.fieldsValue  // {} | to_entries[]? | select(.value.name? == $fid) | .value.value?),
                  ($m.values       // {} | to_entries[]? | select(.value.name? == $fid) | .value.value?)
                ) // empty
              end;

          # Turn sections into pseudo-fields
          def section_fields($m):
            ($m.sections // [])
            | map({ label: (.title // .name // .label // ""), value: (.content // .text // "") })
            | map(select((.label|length)>0 and (.value|tostring|length)>0));

          {
            lastChange: (if $lc=="" then null else (try ($lc|tonumber/1000|todate) catch .) end),
            membersFronting: (
              # Prefer shell-computed IDs; if empty, recompute from $fh here as a fallback
              (( ($ids_json // []) | if length>0 then . else (
                  ($fh
                   | ( . as $a
                     | ( $a
                         | sort_by(.content.member, (.content.lastOperationTime // .content.startTime // 0))
                         | group_by(.content.member)
                         | map( max_by(.content.lastOperationTime // .content.startTime // 0) )
                         | map(select(.content.live == true))
                         | map(.content.member)
                       )
                     + ( $a | map(select(.content.live==true)) | map(.content.member) )
                     | unique )
                  )
                ) end ) ) as $ids
              | $ids
              | map(
                  . as $mid
                  | ( (($mem + $mem_extra)[] | select(.id==$mid) | .content) // null ) as $m
                  | if $m == null then
                      { id: $mid, displayName: null, pronouns: null, avatar: null, color: null, description: null, fields: [] }
                    else
                      # collect candidate fieldIds present on this member
                      (
                        ( ($m.fields       // {} | to_entries[]? | (.[].key) ),      # internal keys
                          ($m.fieldValues  // {} | to_entries[]? | (.[].key) ),
                          ($m.fieldsValue  // {} | to_entries[]? | (.[].key) ),
                          ($m.values       // {} | to_entries[]? | (.[].key) ),
                          # plus ids referenced as .name
                          ($m.fields       // {} | to_entries[]? | .value.name?),
                          ($m.fieldValues  // {} | to_entries[]? | .value.name?),
                          ($m.fieldsValue  // {} | to_entries[]? | .value.name?),
                          ($m.values       // {} | to_entries[]? | .value.name?),
                          # arrays
                          ($m.fields       // [] | .[]? | (.id // .name)),
                          ($m.infoFields   // [] | .[]? | (.id // .name))
                        ) | flatten | map(select(. != null and . != "")) | unique
                      ) as $fids
                      | ( $fdef | to_label_map ) as $labels
                      | (
                          $fids
                          | map({
                              fid: .,
                              label: ($labels[.] // .),
                              value: (value_for($m; .))
                            })
                          | map(select(.value != null and (.value|tostring|length)>0))
                          | map({ label, value })
                        + section_fields($m)
                        ) as $all
                      | {
                          id: $mid,
                          displayName: $m.name,
                          pronouns: $m.pronouns,
                          avatar: $m.avatarUrl,
                          color: $m.color,
                          description: ($m.desc // $m.info // null),
                          fields: ($all | unique_by(.label,.value))
                        }
                  end
                )
            )
          }' > "${PAGES_DIR}/fronts.json"

          echo "Wrote $(wc -c < "${PAGES_DIR}/fronts.json") bytes to fronts.json"
          head -c 400 "${PAGES_DIR}/fronts.json" || true; echo

      - name: Validate JSON
        shell: bash
        env:
          PAGES_DIR: ${{ env.PAGES_DIR }}
        run: |
          python -c "import json,io; p='${{ env.PAGES_DIR }}/fronts.json'; j=json.load(io.open(p,'r',encoding='utf-8')); assert isinstance(j,dict) and 'membersFronting' in j; print('✅ fronts.json ok; membersFronting:', len(j.get('membersFronting',[])))"

      - name: Commit and push if changed
        shell: bash
        env:
          PAGES_BRANCH: ${{ env.PAGES_BRANCH }}
          PAGES_DIR: ${{ env.PAGES_DIR }}
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git pull --rebase --autostash origin "${PAGES_BRANCH}" || true
          git add "${PAGES_DIR}/fronts.json"
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "Update fronts.json [skip ci]"
          git push origin "${PAGES_BRANCH}"